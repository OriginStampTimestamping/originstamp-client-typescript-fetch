/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * OriginStamp Client
 *
 * OpenAPI spec version: 3.0
 * OriginStamp Documentation: https://docs.originstamp.com
 * Contact: mail@originstamp.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.originstamp.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Contains the currency ID and currency name
 * @export
 * @interface CurrencyModel
 */
export interface CurrencyModel {
    /**
     * Name of the currency (uppercase)
     * @type {string}
     * @memberof CurrencyModel
     */
    currency?: string;
    /**
     * ID of the currency, e.g. 0: Bitcoin 1: Ethereum
     * @type {number}
     * @memberof CurrencyModel
     */
    currency_id?: number;
}

/**
 * The default service response object uses error code and message to indicate errors. These errors are handled by the client.
 * @export
 * @interface DefaultOfDownloadLinkResponse
 */
export interface DefaultOfDownloadLinkResponse {
    /**
     * Generic response object which contains the response data, e.g. timestamp information.
     * @type {DownloadLinkResponse}
     * @memberof DefaultOfDownloadLinkResponse
     */
    data?: DownloadLinkResponse;
    /**
     * Contains the error of the request. If the error code is 0, everything is fine.
     * @type {number}
     * @memberof DefaultOfDownloadLinkResponse
     */
    error_code?: number;
    /**
     * Contains the error message, that possibly occurred. If it is empty, everything is fine.
     * @type {string}
     * @memberof DefaultOfDownloadLinkResponse
     */
    error_message?: string;
}

/**
 * The default service response object uses error code and message to indicate errors. These errors are handled by the client.
 * @export
 * @interface DefaultOfListOfCurrencyModel
 */
export interface DefaultOfListOfCurrencyModel {
    /**
     * Generic response object which contains the response data, e.g. timestamp information.
     * @type {Array<CurrencyModel>}
     * @memberof DefaultOfListOfCurrencyModel
     */
    data?: Array<CurrencyModel>;
    /**
     * Contains the error of the request. If the error code is 0, everything is fine.
     * @type {number}
     * @memberof DefaultOfListOfCurrencyModel
     */
    error_code?: number;
    /**
     * Contains the error message, that possibly occurred. If it is empty, everything is fine.
     * @type {string}
     * @memberof DefaultOfListOfCurrencyModel
     */
    error_message?: string;
}

/**
 * The default service response object uses error code and message to indicate errors. These errors are handled by the client.
 * @export
 * @interface DefaultOfTimestampData
 */
export interface DefaultOfTimestampData {
    /**
     * Generic response object which contains the response data, e.g. timestamp information.
     * @type {TimestampData}
     * @memberof DefaultOfTimestampData
     */
    data?: TimestampData;
    /**
     * Contains the error of the request. If the error code is 0, everything is fine.
     * @type {number}
     * @memberof DefaultOfTimestampData
     */
    error_code?: number;
    /**
     * Contains the error message, that possibly occurred. If it is empty, everything is fine.
     * @type {string}
     * @memberof DefaultOfTimestampData
     */
    error_message?: string;
}

/**
 * The default service response object uses error code and message to indicate errors. These errors are handled by the client.
 * @export
 * @interface DefaultOfTimestampResponse
 */
export interface DefaultOfTimestampResponse {
    /**
     * Generic response object which contains the response data, e.g. timestamp information.
     * @type {TimestampResponse}
     * @memberof DefaultOfTimestampResponse
     */
    data?: TimestampResponse;
    /**
     * Contains the error of the request. If the error code is 0, everything is fine.
     * @type {number}
     * @memberof DefaultOfTimestampResponse
     */
    error_code?: number;
    /**
     * Contains the error message, that possibly occurred. If it is empty, everything is fine.
     * @type {string}
     * @memberof DefaultOfTimestampResponse
     */
    error_message?: string;
}

/**
 * The default service response object uses error code and message to indicate errors. These errors are handled by the client.
 * @export
 * @interface DefaultOfVoid
 */
export interface DefaultOfVoid {
    /**
     * Contains the error of the request. If the error code is 0, everything is fine.
     * @type {number}
     * @memberof DefaultOfVoid
     */
    error_code?: number;
    /**
     * Contains the error message, that possibly occurred. If it is empty, everything is fine.
     * @type {string}
     * @memberof DefaultOfVoid
     */
    error_message?: string;
}

/**
 * The default service response object uses error code and message to indicate errors. These errors are handled by the client.
 * @export
 * @interface DefaultOfWebhookResponse
 */
export interface DefaultOfWebhookResponse {
    /**
     * Generic response object which contains the response data, e.g. timestamp information.
     * @type {WebhookResponse}
     * @memberof DefaultOfWebhookResponse
     */
    data?: WebhookResponse;
    /**
     * Contains the error of the request. If the error code is 0, everything is fine.
     * @type {number}
     * @memberof DefaultOfWebhookResponse
     */
    error_code?: number;
    /**
     * Contains the error message, that possibly occurred. If it is empty, everything is fine.
     * @type {string}
     * @memberof DefaultOfWebhookResponse
     */
    error_message?: string;
}

/**
 * The default service response object uses error code and message to indicate errors. These errors are handled by the client.
 * @export
 * @interface DefaultOfstring
 */
export interface DefaultOfstring {
    /**
     * Generic response object which contains the response data, e.g. timestamp information.
     * @type {string}
     * @memberof DefaultOfstring
     */
    data?: string;
    /**
     * Contains the error of the request. If the error code is 0, everything is fine.
     * @type {number}
     * @memberof DefaultOfstring
     */
    error_code?: number;
    /**
     * Contains the error message, that possibly occurred. If it is empty, everything is fine.
     * @type {string}
     * @memberof DefaultOfstring
     */
    error_message?: string;
}

/**
 * The default service response object uses error code and message to indicate errors. These errors are handled by the client.
 * @export
 * @interface DefaultUsageResponse
 */
export interface DefaultUsageResponse {
    /**
     * Generic response object which contains the response data, e.g. timestamp information.
     * @type {UsageResponse}
     * @memberof DefaultUsageResponse
     */
    data?: UsageResponse;
    /**
     * Contains the error of the request. If the error code is 0, everything is fine.
     * @type {number}
     * @memberof DefaultUsageResponse
     */
    error_code?: number;
    /**
     * Contains the error message, that possibly occurred. If it is empty, everything is fine.
     * @type {string}
     * @memberof DefaultUsageResponse
     */
    error_message?: string;
}

/**
 * DTO for the download link of a proof request.
 * @export
 * @interface DownloadLinkResponse
 */
export interface DownloadLinkResponse {
    /**
     * URL to download file.
     * @type {string}
     * @memberof DownloadLinkResponse
     */
    download_url?: string;
    /**
     * File name of downloaded file.
     * @type {string}
     * @memberof DownloadLinkResponse
     */
    file_name?: string;
    /**
     * File size in bytes.
     * @type {number}
     * @memberof DownloadLinkResponse
     */
    file_size_bytes?: number;
}

/**
 * Request object for a manual webhook request.
 * @export
 * @interface ManualWebhookRequest
 */
export interface ManualWebhookRequest {
    /**
     * SHA-256 Hash in Hex representation.
     * @type {string}
     * @memberof ManualWebhookRequest
     */
    hash: string;
    /**
     * The target URL to which we send the timestamp information of the requested hash via a post request.
     * @type {string}
     * @memberof ManualWebhookRequest
     */
    webhook_url: string;
}

/**
 * DTO object for notifications.
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 0: Bitcoin
     * @type {number}
     * @memberof Notification
     */
    currency: number;
    /**
     * 0: notify via email  1: notify a webhook
     * @type {number}
     * @memberof Notification
     */
    notification_type: number;
    /**
     * Depending on the notification type, specify the target for the notification (e.g. mail address or webhook URL). The webhook URL will receive a POST request after timestamp was successfully created.
     * @type {string}
     * @memberof Notification
     */
    target: string;
}

/**
 * Request object for proof request.
 * @export
 * @interface ProofRequest
 */
export interface ProofRequest {
    /**
     * 0: Bitcoin 1: Ethereum 2: AION 100: Südkurier
     * @type {number}
     * @memberof ProofRequest
     */
    currency: number;
    /**
     * Hash in HEX representation for which the proof should be created. We allow the use of SHA-256. Note: We handle the hashes in lower-case.
     * @type {string}
     * @memberof ProofRequest
     */
    hash_string: string;
    /**
     * Specifies which type of file should be returned. Possible value(s):  0: proof with a seed file (txt) or proof with a merkle tree (xml) 1: proof with a PDF file   Other formats will follow.
     * @type {number}
     * @memberof ProofRequest
     */
    proof_type: number;
}

/**
 * Request object for bulk timestamping request.
 * @export
 * @interface TimestampBulkRequest
 */
export interface TimestampBulkRequest {
    /**
     * Array of timestamp request DTOs which will be timestamped.
     * @type {Array<TimestampRequest>}
     * @memberof TimestampBulkRequest
     */
    timestamps: Array<TimestampRequest>;
}

/**
 * DTO for the timestamp data.
 * @export
 * @interface TimestampData
 */
export interface TimestampData {
    /**
     * 0: Bitcoin
     * @type {number}
     * @memberof TimestampData
     */
    currency_id?: number;
    /**
     * The private key represents the top hash in the Merkle Tree (see https://en.wikipedia.org/wiki/Merkle_tree ) or the hash of all hashes in the transaction.
     * @type {string}
     * @memberof TimestampData
     */
    private_key?: string;
    /**
     * ID of associated seed which can be used to request separate seed information.
     * @type {string}
     * @memberof TimestampData
     */
    seed_id?: string;
    /**
     * The submit status of the hash:   0: the hash was not broadcasted yet  1: the hash was included into a transaction and broadcasted to the network, but not included into a block  2: the transaction was included into the latest block  3: the timestamp for your hash was successfully created.
     * @type {number}
     * @memberof TimestampData
     */
    submit_status?: number;
    /**
     * The date is returned in the following format: [ms] since 1.1.1970 (unix epoch), timezone: UTC. This is a true timestamp.
     * @type {number}
     * @memberof TimestampData
     */
    timestamp?: number;
    /**
     * If available: the transaction hash of the timestamp.
     * @type {string}
     * @memberof TimestampData
     */
    transaction?: string;
}

/**
 * request object for a timestamp request.
 * @export
 * @interface TimestampRequest
 */
export interface TimestampRequest {
    /**
     * You can add a short comment (max. 256 characters) which can be used for indexing and searching (public).
     * @type {string}
     * @memberof TimestampRequest
     */
    comment?: string;
    /**
     * Hash in HEX representation. We suggest to use SHA-256. This hash will be aggregated and included into the blockchain.
     * @type {string}
     * @memberof TimestampRequest
     */
    hash: string;
    /**
     * Add a notification/notification list to your submission. Our system will notify the specified target with the timestamp information.
     * @type {Array<Notification>}
     * @memberof TimestampRequest
     */
    notifications?: Array<Notification>;
}

/**
 * Response object for the timestamp response. Create, Status and Webhookshare the same object. This saves customers additional implementation work, as the requests or data only have to be understood once.The difference is that the webhook is only triggered as soon as a tamper-proof timestamp exists.
 * @export
 * @interface TimestampResponse
 */
export interface TimestampResponse {
    /**
     * The comment which was added in the submission of the hash.
     * @type {string}
     * @memberof TimestampResponse
     */
    comment?: string;
    /**
     * Field is set to true if it is a novel hash.If the flag is false, the hash was already submitted before.
     * @type {boolean}
     * @memberof TimestampResponse
     */
    created?: boolean;
    /**
     * The time when your hash was submitted to OriginStamp. The date is returned in the following format: [ms] since 1.1.1970 (unix epoch), timezone: UTC. This is not considered as a true timestamp.
     * @type {number}
     * @memberof TimestampResponse
     */
    date_created?: number;
    /**
     * The submitted hash in hex representation.
     * @type {string}
     * @memberof TimestampResponse
     */
    hash_string?: string;
    /**
     * Contains all the timestamp data of your hash until now.
     * @type {Array<TimestampData>}
     * @memberof TimestampResponse
     */
    timestamps?: Array<TimestampData>;
}

/**
 * Usage metric for this month.
 * @export
 * @interface UsageResponse
 */
export interface UsageResponse {
    /**
     * Total number of certificates available per month.
     * @type {number}
     * @memberof UsageResponse
     */
    certificate_per_month?: number;
    /**
     * Number of certificates requested for the current month.
     * @type {number}
     * @memberof UsageResponse
     */
    consumed_certificates?: number;
    /**
     * Number of used credits for the current month.
     * @type {number}
     * @memberof UsageResponse
     */
    consumed_credits?: number;
    /**
     * Number of timestamps created for the current month.
     * @type {number}
     * @memberof UsageResponse
     */
    consumed_timestamps?: number;
    /**
     * Represents the total number of credits per month.
     * @type {number}
     * @memberof UsageResponse
     */
    credits_per_month?: number;
    /**
     * Determines which usage metric is applied (0 = credits, 1 = timestamps).
     * @type {number}
     * @memberof UsageResponse
     */
    limitation_type?: number;
    /**
     * Remaining number of credits for the current month.
     * @type {number}
     * @memberof UsageResponse
     */
    remaining_credits?: number;
    /**
     * Total number of timestamps available per month.
     * @type {number}
     * @memberof UsageResponse
     */
    timestamps_per_month?: number;
}

/**
 * Request object for a webhook request.
 * @export
 * @interface WebhookRequest
 */
export interface WebhookRequest {
    /**
     * Currency ID for which the webhook should be executed. Possible values: 0: Bitcoin 1: Ethereum 2: AION 100: Südkurier
     * @type {number}
     * @memberof WebhookRequest
     */
    currency?: number;
    /**
     * Hash (SHA-256 in HEX) for which a notification is requested.
     * @type {string}
     * @memberof WebhookRequest
     */
    hash?: string;
    /**
     * Target address to which a POST request should be executed.
     * @type {string}
     * @memberof WebhookRequest
     */
    target?: string;
}

/**
 * response object for a webhook request. Contains only the most recent webhook information for target URL, hash and currency.
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * Currency for which the webhook is triggered, e.g.  0: Bitcoin 1: Ethereum
     * @type {number}
     * @memberof WebhookResponse
     */
    currency?: number;
    /**
     * Shows if the webhook was executed.
     * @type {boolean}
     * @memberof WebhookResponse
     */
    executed?: boolean;
    /**
     * The submitted hash in hex representation.
     * @type {string}
     * @memberof WebhookResponse
     */
    hash?: string;
    /**
     * Indicates whether the webhook was executed successfully or not.
     * @type {boolean}
     * @memberof WebhookResponse
     */
    success?: boolean;
    /**
     * Returns the number of tries for the webhook execution.
     * @type {number}
     * @memberof WebhookResponse
     */
    tries?: number;
}


/**
 * APIKeyApi - fetch parameter creator
 * @export
 */
export const APIKeyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * With this interface you can receive the current usage of your API key. The usage statistic refers to the associated account.
         * @summary Usage
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeyUsage(authorization: string, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getApiKeyUsage.');
            }
            const localVarPath = `/v3/api_key/usage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeyApi - functional programming interface
 * @export
 */
export const APIKeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * With this interface you can receive the current usage of your API key. The usage statistic refers to the associated account.
         * @summary Usage
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeyUsage(authorization: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultUsageResponse> {
            const localVarFetchArgs = APIKeyApiFetchParamCreator(configuration).getApiKeyUsage(authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * APIKeyApi - factory interface
 * @export
 */
export const APIKeyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * With this interface you can receive the current usage of your API key. The usage statistic refers to the associated account.
         * @summary Usage
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeyUsage(authorization: string, options?: any) {
            return APIKeyApiFp(configuration).getApiKeyUsage(authorization, options)(fetch, basePath);
        },
    };
};

/**
 * APIKeyApi - object-oriented interface
 * @export
 * @class APIKeyApi
 * @extends {BaseAPI}
 */
export class APIKeyApi extends BaseAPI {
    /**
     * With this interface you can receive the current usage of your API key. The usage statistic refers to the associated account.
     * @summary Usage
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeyApi
     */
    public getApiKeyUsage(authorization: string, options?: any) {
        return APIKeyApiFp(this.configuration).getApiKeyUsage(authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * BulkApi - fetch parameter creator
 * @export
 */
export const BulkApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * With this interface you can submit multiple hashes at once. If your API key is valid, your hashes are added to seeds and scheduled for timestamping. You are also able to submit additional information with every hash, such as a comment or notification target. If the hash already exists, the 'created' field in the response is set to 'false' and the notification(s) of the corresponding hash will be ignored. To later query the status of any hash for a certain blockchain you can use the 'seed_id' field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook for a submitted hash is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
         * @summary Bulk Submission
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {TimestampBulkRequest} timestampBulkRequest DTO for the bulk hash submission. Add all relevant information concerning your hash submissions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulkTimestamp(authorization: string, timestampBulkRequest: TimestampBulkRequest, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling createBulkTimestamp.');
            }
            // verify required parameter 'timestampBulkRequest' is not null or undefined
            if (timestampBulkRequest === null || timestampBulkRequest === undefined) {
                throw new RequiredError('timestampBulkRequest','Required parameter timestampBulkRequest was null or undefined when calling createBulkTimestamp.');
            }
            const localVarPath = `/v4/timestamp/bulk/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TimestampBulkRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(timestampBulkRequest || {}) : (timestampBulkRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
         * @summary Seed Status
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {string} seedId ID of the timestamp seed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeedStatus(authorization: string, seedId: string, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getSeedStatus.');
            }
            // verify required parameter 'seedId' is not null or undefined
            if (seedId === null || seedId === undefined) {
                throw new RequiredError('seedId','Required parameter seedId was null or undefined when calling getSeedStatus.');
            }
            const localVarPath = `/v4/timestamp/status/seed/{seed_id}`
                .replace(`{${"seed_id"}}`, encodeURIComponent(String(seedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BulkApi - functional programming interface
 * @export
 */
export const BulkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * With this interface you can submit multiple hashes at once. If your API key is valid, your hashes are added to seeds and scheduled for timestamping. You are also able to submit additional information with every hash, such as a comment or notification target. If the hash already exists, the 'created' field in the response is set to 'false' and the notification(s) of the corresponding hash will be ignored. To later query the status of any hash for a certain blockchain you can use the 'seed_id' field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook for a submitted hash is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
         * @summary Bulk Submission
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {TimestampBulkRequest} timestampBulkRequest DTO for the bulk hash submission. Add all relevant information concerning your hash submissions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulkTimestamp(authorization: string, timestampBulkRequest: TimestampBulkRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DefaultOfTimestampResponse>> {
            const localVarFetchArgs = BulkApiFetchParamCreator(configuration).createBulkTimestamp(authorization, timestampBulkRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
         * @summary Seed Status
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {string} seedId ID of the timestamp seed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeedStatus(authorization: string, seedId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultOfTimestampData> {
            const localVarFetchArgs = BulkApiFetchParamCreator(configuration).getSeedStatus(authorization, seedId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BulkApi - factory interface
 * @export
 */
export const BulkApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * With this interface you can submit multiple hashes at once. If your API key is valid, your hashes are added to seeds and scheduled for timestamping. You are also able to submit additional information with every hash, such as a comment or notification target. If the hash already exists, the 'created' field in the response is set to 'false' and the notification(s) of the corresponding hash will be ignored. To later query the status of any hash for a certain blockchain you can use the 'seed_id' field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook for a submitted hash is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
         * @summary Bulk Submission
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {TimestampBulkRequest} timestampBulkRequest DTO for the bulk hash submission. Add all relevant information concerning your hash submissions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulkTimestamp(authorization: string, timestampBulkRequest: TimestampBulkRequest, options?: any) {
            return BulkApiFp(configuration).createBulkTimestamp(authorization, timestampBulkRequest, options)(fetch, basePath);
        },
        /**
         * With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
         * @summary Seed Status
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {string} seedId ID of the timestamp seed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeedStatus(authorization: string, seedId: string, options?: any) {
            return BulkApiFp(configuration).getSeedStatus(authorization, seedId, options)(fetch, basePath);
        },
    };
};

/**
 * BulkApi - object-oriented interface
 * @export
 * @class BulkApi
 * @extends {BaseAPI}
 */
export class BulkApi extends BaseAPI {
    /**
     * With this interface you can submit multiple hashes at once. If your API key is valid, your hashes are added to seeds and scheduled for timestamping. You are also able to submit additional information with every hash, such as a comment or notification target. If the hash already exists, the 'created' field in the response is set to 'false' and the notification(s) of the corresponding hash will be ignored. To later query the status of any hash for a certain blockchain you can use the 'seed_id' field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook for a submitted hash is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
     * @summary Bulk Submission
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {TimestampBulkRequest} timestampBulkRequest DTO for the bulk hash submission. Add all relevant information concerning your hash submissions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkApi
     */
    public createBulkTimestamp(authorization: string, timestampBulkRequest: TimestampBulkRequest, options?: any) {
        return BulkApiFp(this.configuration).createBulkTimestamp(authorization, timestampBulkRequest, options)(this.fetch, this.basePath);
    }

    /**
     * With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
     * @summary Seed Status
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {string} seedId ID of the timestamp seed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkApi
     */
    public getSeedStatus(authorization: string, seedId: string, options?: any) {
        return BulkApiFp(this.configuration).getSeedStatus(authorization, seedId, options)(this.fetch, this.basePath);
    }

}

/**
 * ProofApi - fetch parameter creator
 * @export
 */
export const ProofApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates the download URL for Proof (Seed / Merkle Tree). This interface must be used to obtain the proof or certificate of your tamper-proof timestamp. The parameters are as follows: Cryptocurrency (e.g., Bitcoin, Ethereum,..), type of evidence (e.g., certificate, merkle tree) and the associated hash. The entries are analyzed, e.g., whether a valid timestamp exists for the hash. Then the URL and the filename are returned, with which your proof can be saved. Please note that the download link is only valid for 5 minutes. When using cURL to fetch the proof with the download link make sure to specify \"application/octet-stream\" in the \"Accept\" header.
         * @summary Proof
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {ProofRequest} proofRequestUrl Information needed to return the proof.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProof(authorization: string, proofRequestUrl: ProofRequest, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getProof.');
            }
            // verify required parameter 'proofRequestUrl' is not null or undefined
            if (proofRequestUrl === null || proofRequestUrl === undefined) {
                throw new RequiredError('proofRequestUrl','Required parameter proofRequestUrl was null or undefined when calling getProof.');
            }
            const localVarPath = `/v3/timestamp/proof/url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProofRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(proofRequestUrl || {}) : (proofRequestUrl || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProofApi - functional programming interface
 * @export
 */
export const ProofApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generates the download URL for Proof (Seed / Merkle Tree). This interface must be used to obtain the proof or certificate of your tamper-proof timestamp. The parameters are as follows: Cryptocurrency (e.g., Bitcoin, Ethereum,..), type of evidence (e.g., certificate, merkle tree) and the associated hash. The entries are analyzed, e.g., whether a valid timestamp exists for the hash. Then the URL and the filename are returned, with which your proof can be saved. Please note that the download link is only valid for 5 minutes. When using cURL to fetch the proof with the download link make sure to specify \"application/octet-stream\" in the \"Accept\" header.
         * @summary Proof
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {ProofRequest} proofRequestUrl Information needed to return the proof.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProof(authorization: string, proofRequestUrl: ProofRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultOfDownloadLinkResponse> {
            const localVarFetchArgs = ProofApiFetchParamCreator(configuration).getProof(authorization, proofRequestUrl, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProofApi - factory interface
 * @export
 */
export const ProofApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Generates the download URL for Proof (Seed / Merkle Tree). This interface must be used to obtain the proof or certificate of your tamper-proof timestamp. The parameters are as follows: Cryptocurrency (e.g., Bitcoin, Ethereum,..), type of evidence (e.g., certificate, merkle tree) and the associated hash. The entries are analyzed, e.g., whether a valid timestamp exists for the hash. Then the URL and the filename are returned, with which your proof can be saved. Please note that the download link is only valid for 5 minutes. When using cURL to fetch the proof with the download link make sure to specify \"application/octet-stream\" in the \"Accept\" header.
         * @summary Proof
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {ProofRequest} proofRequestUrl Information needed to return the proof.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProof(authorization: string, proofRequestUrl: ProofRequest, options?: any) {
            return ProofApiFp(configuration).getProof(authorization, proofRequestUrl, options)(fetch, basePath);
        },
    };
};

/**
 * ProofApi - object-oriented interface
 * @export
 * @class ProofApi
 * @extends {BaseAPI}
 */
export class ProofApi extends BaseAPI {
    /**
     * Generates the download URL for Proof (Seed / Merkle Tree). This interface must be used to obtain the proof or certificate of your tamper-proof timestamp. The parameters are as follows: Cryptocurrency (e.g., Bitcoin, Ethereum,..), type of evidence (e.g., certificate, merkle tree) and the associated hash. The entries are analyzed, e.g., whether a valid timestamp exists for the hash. Then the URL and the filename are returned, with which your proof can be saved. Please note that the download link is only valid for 5 minutes. When using cURL to fetch the proof with the download link make sure to specify \"application/octet-stream\" in the \"Accept\" header.
     * @summary Proof
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {ProofRequest} proofRequestUrl Information needed to return the proof.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProofApi
     */
    public getProof(authorization: string, proofRequestUrl: ProofRequest, options?: any) {
        return ProofApiFp(this.configuration).getProof(authorization, proofRequestUrl, options)(this.fetch, this.basePath);
    }

}

/**
 * SchedulerApi - fetch parameter creator
 * @export
 */
export const SchedulerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an array with all active currencies.
         * @summary Get active currencies
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCurrencies(authorization: string, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getActiveCurrencies.');
            }
            const localVarPath = `/v3/currencies/get`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulerApi - functional programming interface
 * @export
 */
export const SchedulerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns an array with all active currencies.
         * @summary Get active currencies
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCurrencies(authorization: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultOfListOfCurrencyModel> {
            const localVarFetchArgs = SchedulerApiFetchParamCreator(configuration).getActiveCurrencies(authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SchedulerApi - factory interface
 * @export
 */
export const SchedulerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns an array with all active currencies.
         * @summary Get active currencies
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveCurrencies(authorization: string, options?: any) {
            return SchedulerApiFp(configuration).getActiveCurrencies(authorization, options)(fetch, basePath);
        },
    };
};

/**
 * SchedulerApi - object-oriented interface
 * @export
 * @class SchedulerApi
 * @extends {BaseAPI}
 */
export class SchedulerApi extends BaseAPI {
    /**
     * Returns an array with all active currencies.
     * @summary Get active currencies
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulerApi
     */
    public getActiveCurrencies(authorization: string, options?: any) {
        return SchedulerApiFp(this.configuration).getActiveCurrencies(authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * TimestampApi - fetch parameter creator
 * @export
 */
export const TimestampApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the 'created' field in the response is set to 'false' and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the 'seed_id' field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
         * @summary Submission
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {TimestampRequest} timestampRequest DTO for the hash submission. Add all relevant information concerning your hash submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimestamp(authorization: string, timestampRequest: TimestampRequest, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling createTimestamp.');
            }
            // verify required parameter 'timestampRequest' is not null or undefined
            if (timestampRequest === null || timestampRequest === undefined) {
                throw new RequiredError('timestampRequest','Required parameter timestampRequest was null or undefined when calling createTimestamp.');
            }
            const localVarPath = `/v4/timestamp/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TimestampRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(timestampRequest || {}) : (timestampRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All 'created' fields are always set to false for a status request.
         * @summary Status
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {string} hashString The hash in string representation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashStatus(authorization: string, hashString: string, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getHashStatus.');
            }
            // verify required parameter 'hashString' is not null or undefined
            if (hashString === null || hashString === undefined) {
                throw new RequiredError('hashString','Required parameter hashString was null or undefined when calling getHashStatus.');
            }
            const localVarPath = `/v4/timestamp/{hash_string}`
                .replace(`{${"hash_string"}}`, encodeURIComponent(String(hashString)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
         * @summary Seed Status
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {string} seedId ID of the timestamp seed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeedStatus(authorization: string, seedId: string, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getSeedStatus.');
            }
            // verify required parameter 'seedId' is not null or undefined
            if (seedId === null || seedId === undefined) {
                throw new RequiredError('seedId','Required parameter seedId was null or undefined when calling getSeedStatus.');
            }
            const localVarPath = `/v4/timestamp/status/seed/{seed_id}`
                .replace(`{${"seed_id"}}`, encodeURIComponent(String(seedId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimestampApi - functional programming interface
 * @export
 */
export const TimestampApiFp = function(configuration?: Configuration) {
    return {
        /**
         * With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the 'created' field in the response is set to 'false' and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the 'seed_id' field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
         * @summary Submission
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {TimestampRequest} timestampRequest DTO for the hash submission. Add all relevant information concerning your hash submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimestamp(authorization: string, timestampRequest: TimestampRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultOfTimestampResponse> {
            const localVarFetchArgs = TimestampApiFetchParamCreator(configuration).createTimestamp(authorization, timestampRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All 'created' fields are always set to false for a status request.
         * @summary Status
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {string} hashString The hash in string representation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashStatus(authorization: string, hashString: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultOfTimestampResponse> {
            const localVarFetchArgs = TimestampApiFetchParamCreator(configuration).getHashStatus(authorization, hashString, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
         * @summary Seed Status
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {string} seedId ID of the timestamp seed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeedStatus(authorization: string, seedId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultOfTimestampData> {
            const localVarFetchArgs = TimestampApiFetchParamCreator(configuration).getSeedStatus(authorization, seedId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TimestampApi - factory interface
 * @export
 */
export const TimestampApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the 'created' field in the response is set to 'false' and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the 'seed_id' field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
         * @summary Submission
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {TimestampRequest} timestampRequest DTO for the hash submission. Add all relevant information concerning your hash submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimestamp(authorization: string, timestampRequest: TimestampRequest, options?: any) {
            return TimestampApiFp(configuration).createTimestamp(authorization, timestampRequest, options)(fetch, basePath);
        },
        /**
         * This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All 'created' fields are always set to false for a status request.
         * @summary Status
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {string} hashString The hash in string representation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashStatus(authorization: string, hashString: string, options?: any) {
            return TimestampApiFp(configuration).getHashStatus(authorization, hashString, options)(fetch, basePath);
        },
        /**
         * With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
         * @summary Seed Status
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {string} seedId ID of the timestamp seed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeedStatus(authorization: string, seedId: string, options?: any) {
            return TimestampApiFp(configuration).getSeedStatus(authorization, seedId, options)(fetch, basePath);
        },
    };
};

/**
 * TimestampApi - object-oriented interface
 * @export
 * @class TimestampApi
 * @extends {BaseAPI}
 */
export class TimestampApi extends BaseAPI {
    /**
     * With this interface you can submit your hash. If your API key is valid, your hash is added  seeds and scheduled for timestamping. You are also able to submit additional information, such as a comment or notification target. If the hash already exists, the 'created' field in the response is set to 'false' and any notification(s) for this hash will be ignored. To later query the status of the hash for a certain blockchain you can use the 'seed_id' field of its inner timestamp structure. This field can be used to query the timestamping status of the selected seed. This is recommended if a large number of hashes were transmitted in a certain time frame. Once a hash is successfully created for a certain crypto currency, we can notify your desired target with the timestamp information (via POST Request). A webhook is triggered as soon as the tamper-proof timestamp with the selected crypto currency has been created. 
     * @summary Submission
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {TimestampRequest} timestampRequest DTO for the hash submission. Add all relevant information concerning your hash submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimestampApi
     */
    public createTimestamp(authorization: string, timestampRequest: TimestampRequest, options?: any) {
        return TimestampApiFp(this.configuration).createTimestamp(authorization, timestampRequest, options)(this.fetch, this.basePath);
    }

    /**
     * This interface returns information of a certain hash read from the URL path. If the status of several hashes is to be checked, it is preferable to use the seed status interface. This reduces the required requests and can be tailored to a desired blockchain. All 'created' fields are always set to false for a status request.
     * @summary Status
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {string} hashString The hash in string representation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimestampApi
     */
    public getHashStatus(authorization: string, hashString: string, options?: any) {
        return TimestampApiFp(this.configuration).getHashStatus(authorization, hashString, options)(this.fetch, this.basePath);
    }

    /**
     * With this interface you can request the status for a certain seed. This is used when checking the status of previously submitted hashes and avoids sending individual status requests for each hash.
     * @summary Seed Status
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {string} seedId ID of the timestamp seed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimestampApi
     */
    public getSeedStatus(authorization: string, seedId: string, options?: any) {
        return TimestampApiFp(this.configuration).getSeedStatus(authorization, seedId, options)(this.fetch, this.basePath);
    }

}

/**
 * WebhookApi - fetch parameter creator
 * @export
 */
export const WebhookApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * RESTful interface to receive the status of a webhook. Based on the input parameters (target URL, hash and currency), we look up the most recent entry in the notification queue.This method is intended to support the webhook integration.
         * @summary Webhook
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {WebhookRequest} webhookRequest DTO for registering webhook information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookStatus(authorization: string, webhookRequest: WebhookRequest, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getWebhookStatus.');
            }
            // verify required parameter 'webhookRequest' is not null or undefined
            if (webhookRequest === null || webhookRequest === undefined) {
                throw new RequiredError('webhookRequest','Required parameter webhookRequest was null or undefined when calling getWebhookStatus.');
            }
            const localVarPath = `/v3/webhook/information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(webhookRequest || {}) : (webhookRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Method which allows a subscription for a webhook notification. If this method is called, a new entry is added to notification queue that is triggered as soon as a tamper-proof timestamp or the hash is created. An empty data payload means that the entry was created successfully.
         * @summary Webhook
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {WebhookRequest} webhookRequest DTO for querying webhook information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerWebhookNotification(authorization: string, webhookRequest: WebhookRequest, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling registerWebhookNotification.');
            }
            // verify required parameter 'webhookRequest' is not null or undefined
            if (webhookRequest === null || webhookRequest === undefined) {
                throw new RequiredError('webhookRequest','Required parameter webhookRequest was null or undefined when calling registerWebhookNotification.');
            }
            const localVarPath = `/v3/webhook/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(webhookRequest || {}) : (webhookRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With this interface you can trigger manual webhook to see how a webhook looks like. Please use a hash, that was already timestamped before such as https://redir.originstamp.com/hash/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
         * @summary Dev
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {ManualWebhookRequest} manualWebhookRequest DTO for webhook request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTimestampWebhook(authorization: string, manualWebhookRequest: ManualWebhookRequest, options: any = {}): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling triggerTimestampWebhook.');
            }
            // verify required parameter 'manualWebhookRequest' is not null or undefined
            if (manualWebhookRequest === null || manualWebhookRequest === undefined) {
                throw new RequiredError('manualWebhookRequest','Required parameter manualWebhookRequest was null or undefined when calling triggerTimestampWebhook.');
            }
            const localVarPath = `/v3/webhook/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API Key Authorization required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            localVarHeaderParameter['User-Agent'] = 'OriginStamp Client TypeScript/2.0 (Fetch)';
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ManualWebhookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(manualWebhookRequest || {}) : (manualWebhookRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    return {
        /**
         * RESTful interface to receive the status of a webhook. Based on the input parameters (target URL, hash and currency), we look up the most recent entry in the notification queue.This method is intended to support the webhook integration.
         * @summary Webhook
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {WebhookRequest} webhookRequest DTO for registering webhook information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookStatus(authorization: string, webhookRequest: WebhookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultOfWebhookResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).getWebhookStatus(authorization, webhookRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Method which allows a subscription for a webhook notification. If this method is called, a new entry is added to notification queue that is triggered as soon as a tamper-proof timestamp or the hash is created. An empty data payload means that the entry was created successfully.
         * @summary Webhook
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {WebhookRequest} webhookRequest DTO for querying webhook information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerWebhookNotification(authorization: string, webhookRequest: WebhookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultOfVoid> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).registerWebhookNotification(authorization, webhookRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With this interface you can trigger manual webhook to see how a webhook looks like. Please use a hash, that was already timestamped before such as https://redir.originstamp.com/hash/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
         * @summary Dev
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {ManualWebhookRequest} manualWebhookRequest DTO for webhook request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTimestampWebhook(authorization: string, manualWebhookRequest: ManualWebhookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DefaultOfstring> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).triggerTimestampWebhook(authorization, manualWebhookRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * RESTful interface to receive the status of a webhook. Based on the input parameters (target URL, hash and currency), we look up the most recent entry in the notification queue.This method is intended to support the webhook integration.
         * @summary Webhook
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {WebhookRequest} webhookRequest DTO for registering webhook information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookStatus(authorization: string, webhookRequest: WebhookRequest, options?: any) {
            return WebhookApiFp(configuration).getWebhookStatus(authorization, webhookRequest, options)(fetch, basePath);
        },
        /**
         * Method which allows a subscription for a webhook notification. If this method is called, a new entry is added to notification queue that is triggered as soon as a tamper-proof timestamp or the hash is created. An empty data payload means that the entry was created successfully.
         * @summary Webhook
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {WebhookRequest} webhookRequest DTO for querying webhook information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerWebhookNotification(authorization: string, webhookRequest: WebhookRequest, options?: any) {
            return WebhookApiFp(configuration).registerWebhookNotification(authorization, webhookRequest, options)(fetch, basePath);
        },
        /**
         * With this interface you can trigger manual webhook to see how a webhook looks like. Please use a hash, that was already timestamped before such as https://redir.originstamp.com/hash/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
         * @summary Dev
         * @param {string} authorization A valid API key is essential for authorization to handle the request.
         * @param {ManualWebhookRequest} manualWebhookRequest DTO for webhook request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTimestampWebhook(authorization: string, manualWebhookRequest: ManualWebhookRequest, options?: any) {
            return WebhookApiFp(configuration).triggerTimestampWebhook(authorization, manualWebhookRequest, options)(fetch, basePath);
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * RESTful interface to receive the status of a webhook. Based on the input parameters (target URL, hash and currency), we look up the most recent entry in the notification queue.This method is intended to support the webhook integration.
     * @summary Webhook
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {WebhookRequest} webhookRequest DTO for registering webhook information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getWebhookStatus(authorization: string, webhookRequest: WebhookRequest, options?: any) {
        return WebhookApiFp(this.configuration).getWebhookStatus(authorization, webhookRequest, options)(this.fetch, this.basePath);
    }

    /**
     * Method which allows a subscription for a webhook notification. If this method is called, a new entry is added to notification queue that is triggered as soon as a tamper-proof timestamp or the hash is created. An empty data payload means that the entry was created successfully.
     * @summary Webhook
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {WebhookRequest} webhookRequest DTO for querying webhook information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public registerWebhookNotification(authorization: string, webhookRequest: WebhookRequest, options?: any) {
        return WebhookApiFp(this.configuration).registerWebhookNotification(authorization, webhookRequest, options)(this.fetch, this.basePath);
    }

    /**
     * With this interface you can trigger manual webhook to see how a webhook looks like. Please use a hash, that was already timestamped before such as https://redir.originstamp.com/hash/9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 . Usually, the webhook is triggered as soon as the tamper-proof time stamp with the selected crypto currency has been created.
     * @summary Dev
     * @param {string} authorization A valid API key is essential for authorization to handle the request.
     * @param {ManualWebhookRequest} manualWebhookRequest DTO for webhook request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public triggerTimestampWebhook(authorization: string, manualWebhookRequest: ManualWebhookRequest, options?: any) {
        return WebhookApiFp(this.configuration).triggerTimestampWebhook(authorization, manualWebhookRequest, options)(this.fetch, this.basePath);
    }

}

